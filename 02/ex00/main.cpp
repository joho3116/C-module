/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.cpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: johokyoun <johokyoun@student.42.fr>        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/01/11 16:21:22 by johokyoun         #+#    #+#             */
/*   Updated: 2022/01/11 17:51:01 by johokyoun        ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/* 부동소수점 && 고정소수점

컴퓨터가 실수를 표현할 때 쓰는 방법
-> 소수점이 붙어있는 수는 어떻게 2진수로 변환?

소수점 앞부분은 정수 변환 하는 것과 동일
소수점 뒷부분은 정수 변환처럼 바꿔버린다면, 서로 다른 10진수 숫자가 2진수로 변환되었을 때 중복이되는 문제가 발생

소수점 뒷부분은 10진수에 2를 곱해가면서 1과 0을 뽑아내고, 나머지가 0이 될 때 종료한 뒤 결과 반환

ex. 0.625 이진수 변환

0.625 * 2 = 1.25 -> 1을 빼내고 나머지 0.25
0.25 * 2 = 0.5 -> 0을 빼내고 나머지 0.5
0.5 * 2 = 1.0 -> 1을 빼내고 나머지가 0이기에 종료

=> 0.625 -> 0.101

- 고정소수점 표현방식 - 

10진수를 2진수로 변환했다면, 그걸 그대로 비트에 박아넣는 방식

ex. 7.625 이진수 변환 -> 111.101

16비트 체계에서 00000111.10100000
이 때, 가장 앞자리는 부호 비트(sign bit). 0이면 양수, 1이면 음수
나머지 비트들은 소수점 기준으로 정수부, 소수부를 표현하는 비트로 나뉨. 소수점의 위치는 미리 정해둠
정수부는 뒤에서부터, 소수부는 앞에서 채우며 남는 자리는 0으로 채움

구현하기 편리하지만 비트 수 대비 표현가능한 수의 범위 또는 정밀도가 낮기 때문에 실수를 다룰 필요가 있는
범용 시스템에서는 거의 안쓰이고, 높은 정밀도가 필요없는 소규모 시스템에서 간혹 쓰인다.

- 부동소수점 표현방식 -

2진수 변환 결과를 그대로 넣지 않고, 몇가지 과정을 추가로 거친다.

정규화

2진수를 1.xxxx * 2^n 꼴로 변환하는 것.

정수부에 1만 남을 때까지 소수점을 왼쪽 (정수부가 0일 경우 오른쪽)으로 이동 시키고, 
이동한 칸 수만큼 n 자리에 수를 집어넣으면 된다.

111.101 정규화 -> 1.11101 * 2^2

여기서 소수점을 이동시킨다는 데에서 floating point 라는 용어가 나온 것

32비트 기준 첫번째 비트는 부호 비트, 뒤 8자리 지수부, 23자리 가수부
가수부는 정규화 결과 소수점 오른쪽 숫자들을 그대로 넣고, 남는 자리는 0으로 채운다.
지수부는 2^n에서 n에 해당하는 수에 bias라고 하는 지정된 숫자를 더한 후 넣어야 한다.

IEEE 표준에서 32비트의 경우 bias는 127이라고 규정

7.625 부동소수점 표현
-> 2진수 변환 111.101
-> 정규화 1.11101 * 2^2
부호비트 0, 소수점 부분은 가수부에 삽입, 지수부에는 2 + 127 = 129를 2진수로 변환 -> 10000001을 삽입

-> 01000000111101000000000000000000

bias는 지수가 음수가 될 수도 있기 때문에
ex. 0.000101 이진수를 정규화를 시키면 오른쪽으로 소수점를 밀어서 1.01 *2^-4 가 된다.
이 때, 표현이 어렵기 때문. 따라서 지수부 + bias의 값이 0 ~ 127인 경우 음수, 128 ~ 255는 양수 구간

비트 수 대비 표현가능한 수의 범위와 정밀도가 고정소수점 표현방식보다 낫기 때문에 불편함을 감수하고 대부분에 컴퓨터 시스템에서 사용되고 있음.

- float && double -

32비트 표현을 float, 64비트 표현을 double

double에서는 지수부 11비트, 가수부 52비트, bias는 1023


*/

#include <iostream>
#include "Fixed.hpp"

int main( void )
{
    Fixed a;
    Fixed b( a );
    Fixed c;

    c = b;

    std::cout << a.getRawBits() << std::endl;
    std::cout << b.getRawBits() << std::endl;
    std::cout << c.getRawBits() << std::endl;

    return (0);
}